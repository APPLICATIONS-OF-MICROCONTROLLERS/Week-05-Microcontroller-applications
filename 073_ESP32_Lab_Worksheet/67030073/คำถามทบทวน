1. Docker Commands  
คำสั่ง `docker-compose up -d` ทำหน้าที่ในการเปิด container สำหรับใช้งาน ESP32 โดยให้รันอยู่เบื้องหลังโดยไม่แสดงผลหน้าจอทันที  
คำสั่ง `docker-compose exec esp32-dev bash` ใช้เพื่อเข้าสู่ container ชื่อ esp32-dev ซึ่งภายในมีสภาพแวดล้อมพร้อมสำหรับการพัฒนา เช่น การ build และทดสอบโปรแกรม ESP32  

2. ESP-IDF Tools  
เครื่องมือหลักที่ใช้ในการ build โปรแกรม ESP32 ใน Lab4 คือ `idf.py` ซึ่งเป็น utility ของ ESP-IDF ที่ใช้ในการ compile, flash โปรแกรมไปยังบอร์ด และตรวจสอบ output ผ่าน serial monitor  

3. New Tools  
เครื่องมือที่เพิ่มมาใหม่ เช่น `tree` และ `htop` มีประโยชน์ในการตรวจสอบระบบ โดย `tree` ใช้ในการดูโครงสร้างไฟล์แบบแสดงลำดับขั้น ในขณะที่ `htop` ใช้ตรวจสอบการทำงานของ CPU และ memory แบบ real-time รวมถึงดู process ที่กำลังทำงานอยู่  

4. Architecture Focus  
การศึกษาโครงสร้างภายในของ ESP32 เช่น memory layout, การทำงานของ core และการเชื่อมต่อกับอุปกรณ์ต่าง ๆ เป็นการทำความเข้าใจเชิงลึกเกี่ยวกับ hardware และระบบซอฟต์แวร์ในระดับ platform  
ในขณะที่ Lab4 เน้นการเขียนภาษา C สำหรับการคำนวณและสร้าง logic โดยใช้ความรู้พื้นฐานของโปรแกรมมิ่งมากกว่าการลงรายละเอียดทางสถาปัตยกรรมของชิป

---

คำถามวิเคราะห์ง่าย 2.1

1. Memory Types  
SRAM มีไว้สำหรับจัดเก็บข้อมูลที่เปลี่ยนแปลงได้ขณะโปรแกรมทำงาน เช่น stack, heap และตัวแปรทั่วไป  
ส่วน Flash memory เก็บข้อมูลแบบถาวร เช่น firmware, โค้ดโปรแกรมที่ผ่านการ compile แล้ว และค่าคงที่ที่ไม่เปลี่ยนระหว่างการทำงาน  

2. Address Ranges  
ตัวแปรประเภทต่าง ๆ จะอยู่ในช่วง address ที่แตกต่างกัน เช่น  
Global หรือ static variables จะอยู่ใน section .data และ .bss (ใน SRAM)  
ตัวแปรที่ประกาศภายในฟังก์ชันจะอยู่บน stack  
ส่วน memory ที่จองแบบ dynamic (malloc) จะอยู่ใน heap  
ค่าคงที่หรือโค้ดโปรแกรมจะถูกเก็บไว้ใน flash memory  

3. Memory Usage  
ESP32 มีหน่วยความจำแบบ Flash ประมาณ 4MB และ SRAM ภายในประมาณ 520KB ซึ่งถูกแบ่งออกเป็นหลายส่วน การใช้งานจริงของ memory ขึ้นอยู่กับขนาดและลักษณะของโปรแกรม โดยสามารถตรวจสอบได้จากผลลัพธ์หลังการ compile เช่นข้อมูลใน section text, data และ bss

---

คำถามวิเคราะห์ 3.1

1. Cache Efficiency  
การอ่านข้อมูลแบบต่อเนื่อง (sequential) ช่วยให้ cache ทำงานได้เต็มประสิทธิภาพ เพราะโหลดข้อมูลไว้ล่วงหน้าได้ทันเวลา  
ในทางตรงกันข้าม การเข้าถึงข้อมูลแบบสุ่ม (random) จะทำให้เกิด cache miss บ่อยครั้ง เพราะข้อมูลที่ต้องการไม่ได้อยู่ใน block ที่โหลดมา  

2. Memory Hierarchy  
SRAM ที่ฝังใน ESP32 มีความเร็วในการเข้าถึงสูงและ latency ต่ำ เหมาะกับการเก็บข้อมูลที่ถูกใช้งานบ่อย  
External memory อย่าง PSRAM มีความจุเยอะกว่า แต่เข้าถึงช้ากว่า เนื่องจากเชื่อมต่อผ่าน bus ภายนอก จึงเหมาะกับการเก็บข้อมูลที่ไม่จำเป็นต้องเข้าถึงตลอดเวลา  

3. Stride Patterns  
ขนาดของ stride ในการอ่านข้อมูลมีผลต่อการทำงานของ cache หาก stride มีค่าต่อเนื่อง เช่น 1 จะช่วยให้ cache ใช้ข้อมูลได้คุ้มค่ายิ่งขึ้น  
แต่ถ้า stride มีค่าห่างมาก เช่น อ่านข้อมูลแบบเว้นช่วง จะทำให้ block ที่โหลดไว้ใน cache ไม่ถูกใช้งานจริง เกิดการ miss บ่อย และลดประสิทธิภาพโดยรวม

---

คำถามวิเคราะห์ 4.1

1. Core Specialization  
จากการทดลอง พบว่า Core 0 เหมาะสำหรับงานเบื้องหลังและระบบ เช่น Wi-Fi, Bluetooth, หรือการจัดการ interrupt  
ขณะที่ Core 1 เหมาะสำหรับงานหลักที่ต้องการการประมวลผล เช่นการรันโค้ดหลัก ที่ต้องการ performance สูง โดยไม่แทรกแซงการทำงานของระบบ  

2. Communication Overhead  
การติดต่อระหว่าง core ทั้งสองอาจมี overhead บ้าง เช่น ต้องมีการจัดการการเข้าถึง memory และ synchronize ข้อมูล ซึ่งอาจทำให้เกิด delay และลดความเร็วลงเมื่อเทียบกับการทำงานใน core เดียว  

3. Load Balancing  
ประสิทธิภาพของการแบ่งงานระหว่าง core จะขึ้นอยู่กับการออกแบบโปรแกรม ถ้ามีการจัดสรรหน้าที่อย่างเหมาะสม เช่น ให้ core หนึ่งจัดการงานระบบ และอีก core หนึ่งจัดการ logic ก็จะช่วยให้ระบบทำงานได้ลื่นไหล  
แต่หากแบ่งไม่ดี อาจทำให้เกิดการใช้งานไม่สมดุล เช่น core หนึ่งทำงานหนักเกินไปในขณะที่อีก core แทบไม่ได้ใช้
